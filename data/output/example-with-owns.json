{
  "id": "example-with-owns",
  "tokens": 799,
  "data": "func Run(rl *fn.ResourceList) (bool, error) {m := mutatorCtx{}var err errorm.fnCondSdk, err = condkptsdk.New(rl,\u0026condkptsdk.Config{For: corev1.ObjectReference{APIVersion: nephioreqv1alpha1.GroupVersion.Identifier(),Kind:    nephioreqv1alpha1.InterfaceKind,},Owns: map[corev1.ObjectReference]condkptsdk.ResourceKind{{APIVersion: nadv1.SchemeGroupVersion.Identifier(),Kind:    reflect.TypeOf(nadv1.NetworkAttachmentDefinition{}).Name(),}: condkptsdk.ChildRemoteCondition,{APIVersion: ipamv1alpha1.GroupVersion.Identifier(),Kind:    ipamv1alpha1.IPAllocationKind,}: condkptsdk.ChildRemote,},Watch: map[corev1.ObjectReference]condkptsdk.WatchCallbackFn{{APIVersion: infrav1alpha1.GroupVersion.Identifier(),Kind:    reflect.TypeOf(infrav1alpha1.ClusterContext{}).Name(),}: m.ClusterContextCallbackFn,},PopulateOwnResourcesFn: m.populateFn,GenerateResourceFn:   m.generateFn,},)if err != nil {rl.Results = append(rl.Results, fn.ErrorResult(err))return false, err}return m.fnCondSdk.Run()}func (r *mutatorCtx) ClusterContextCallbackFn(o *fn.KubeObject) error {clusterContext := clusterctxtlibv1alpha1.NewMutator(o.String())cluster, err := clusterContext.UnMarshal()if err != nil {return err}r.siteCode = *cluster.Spec.SiteCoder.masterInterface = cluster.Spec.CNIConfig.MasterInterfacer.cniType = cluster.Spec.CNIConfig.CNITypereturn nil}func (r *mutatorCtx) populateFn(o *fn.KubeObject) (fn.KubeObjects, error) {resources := fn.KubeObjects{}itfce, err := interfacelibv1alpha1.NewFromKubeObject(o)if err != nil {return nil, err}// we assume right now that if the CNITYpe is not set this is a loopback interfaceif itfce.GetCNIType() != \"\" {// generate network IPAllocationo, err := fn.NewFromTypedObject(alloc)if err != nil {return nil, err}resources = append(resources, o)// generate empty nado, err = fn.NewFromTypedObject(nad)if err != nil {return nil, err}resources = append(resources, o)} else {// generate loopback IPAllocationo, err := fn.NewFromTypedObject(alloc)if err != nil {return nil, err}resources = append(resources, o)}return resources, nil}func (r *mutatorCtx) generateFn(forObj *fn.KubeObject, objs fn.KubeObjects) (*fn.KubeObject, error) {  // a for obj is expectedif forObj == nil {return nil, fmt.Errorf(\"expected a for object but got nil\")}  // get the interface objectitfce, err := interfacelibv1alpha1.NewFromKubeObject(forObj)if err != nil {return nil, err}  // based on the ip allocation fill out the statusipallocs := objs.Where(fn.IsGroupVersionKind(ipamv1alpha1.IPAllocationGroupVersionKind))for _, ipalloc := range ipallocs {if ipalloc.GetName() == forObj.GetName() {alloc, err := ipalloclibv1alpha1.NewFromKubeObject(ipalloc)if err != nil {return nil, err}allocGoStruct, err := alloc.GetGoStruct()if err != nil {return nil, err}if err := itfce.SetIPAllocationStatus(\u0026allocGoStruct.Status); err != nil {return nil, err}}}return \u0026itfce.KubeObject, nil}"
}